-- Generated using RoadToGlory's Converter v1.1 (RoadToGlory#9879)

-- Instances:

local Converted = {
	["_ScreenGui"] = Instance.new("ScreenGui");
	["_move"] = Instance.new("LocalScript");
	["_have"] = Instance.new("Frame");
	["_UIStroke"] = Instance.new("UIStroke");
	["_LocalScript"] = Instance.new("LocalScript");
	["_title"] = Instance.new("TextLabel");
	["_rainbow"] = Instance.new("LocalScript");
	["_boxesp"] = Instance.new("TextLabel");
	["_rainbow1"] = Instance.new("LocalScript");
	["_boxesp1"] = Instance.new("TextButton");
	["_boxesponoff"] = Instance.new("LocalScript");
	["_distance"] = Instance.new("TextButton");
	["_distanceonoff"] = Instance.new("LocalScript");
	["_distance1"] = Instance.new("TextLabel");
	["_rainbow2"] = Instance.new("LocalScript");
	["_chestesp"] = Instance.new("TextLabel");
	["_rainbow3"] = Instance.new("LocalScript");
	["_chestesp1"] = Instance.new("TextButton");
	["_chestesponoff"] = Instance.new("LocalScript");
	["_tpwalk"] = Instance.new("TextButton");
	["_tpwalkonoff"] = Instance.new("LocalScript");
	["_tpwalk1"] = Instance.new("TextLabel");
	["_rainbow4"] = Instance.new("LocalScript");
	["_skinchange"] = Instance.new("TextLabel");
	["_rainbow5"] = Instance.new("LocalScript");
	["_skinchange1"] = Instance.new("TextButton");
	["_skinchangeonoff"] = Instance.new("LocalScript");
	["_line"] = Instance.new("TextLabel");
	["_rainbow6"] = Instance.new("LocalScript");
	["_line1"] = Instance.new("TextButton");
	["_lineonoff"] = Instance.new("LocalScript");
	["_infjump"] = Instance.new("TextLabel");
	["_rainbow7"] = Instance.new("LocalScript");
	["_infjump1"] = Instance.new("TextButton");
	["_infjumponoff"] = Instance.new("LocalScript");
	["_hitbox"] = Instance.new("TextLabel");
	["_rainbow8"] = Instance.new("LocalScript");
	["_hitbox1"] = Instance.new("TextButton");
	["_hitboxonoff"] = Instance.new("LocalScript");
}

-- Properties:

Converted["_ScreenGui"].Parent = game:GetService("CoreGui")

Converted["_have"].BackgroundColor3 = Color3.fromRGB(36.00000165402889, 36.00000165402889, 36.00000165402889)
Converted["_have"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_have"].BorderSizePixel = 0
Converted["_have"].Position = UDim2.new(0.401041657, 0, 0.358333319, 0)
Converted["_have"].Size = UDim2.new(0.197395831, 0, 0.324999988, 0)
Converted["_have"].Name = "have"
Converted["_have"].Parent = Converted["_ScreenGui"]

Converted["_UIStroke"].Color = Color3.fromRGB(255, 0, 0)
Converted["_UIStroke"].Parent = Converted["_have"]

Converted["_title"].Font = Enum.Font.Sarpanch
Converted["_title"].Text = "KUMAO_FortBlox V1.2"
Converted["_title"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_title"].TextSize = 30
Converted["_title"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_title"].BackgroundTransparency = 1
Converted["_title"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_title"].BorderSizePixel = 0
Converted["_title"].Position = UDim2.new(0.421354175, 0, 0.315740734, 0)
Converted["_title"].Size = UDim2.new(0.15677084, 0, 0.0425925925, 0)
Converted["_title"].Name = "title"
Converted["_title"].Parent = Converted["_ScreenGui"]

Converted["_boxesp"].Font = Enum.Font.Sarpanch
Converted["_boxesp"].Text = "BoxEsp"
Converted["_boxesp"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_boxesp"].TextSize = 25
Converted["_boxesp"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_boxesp"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_boxesp"].BackgroundTransparency = 1
Converted["_boxesp"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_boxesp"].BorderSizePixel = 0
Converted["_boxesp"].Position = UDim2.new(0.413541675, 0, 0.370370358, 0)
Converted["_boxesp"].Size = UDim2.new(0.0364583321, 0, 0.0194444451, 0)
Converted["_boxesp"].Name = "boxesp"
Converted["_boxesp"].Parent = Converted["_ScreenGui"]

Converted["_boxesp1"].Font = Enum.Font.Sarpanch
Converted["_boxesp1"].Text = "■"
Converted["_boxesp1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_boxesp1"].TextSize = 20
Converted["_boxesp1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_boxesp1"].BackgroundTransparency = 1
Converted["_boxesp1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_boxesp1"].BorderSizePixel = 0
Converted["_boxesp1"].Position = UDim2.new(0.453125, 0, 0.375, 0)
Converted["_boxesp1"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_boxesp1"].Name = "boxesp"
Converted["_boxesp1"].Parent = Converted["_ScreenGui"]

Converted["_distance"].Font = Enum.Font.Sarpanch
Converted["_distance"].Text = "■"
Converted["_distance"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_distance"].TextSize = 20
Converted["_distance"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_distance"].BackgroundTransparency = 1
Converted["_distance"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_distance"].BorderSizePixel = 0
Converted["_distance"].Position = UDim2.new(0.513020873, 0, 0.376851857, 0)
Converted["_distance"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_distance"].Name = "distance"
Converted["_distance"].Parent = Converted["_ScreenGui"]

Converted["_distance1"].Font = Enum.Font.Sarpanch
Converted["_distance1"].Text = "Distance"
Converted["_distance1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_distance1"].TextSize = 25
Converted["_distance1"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_distance1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_distance1"].BackgroundTransparency = 1
Converted["_distance1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_distance1"].BorderSizePixel = 0
Converted["_distance1"].Position = UDim2.new(0.46874997, 0, 0.372222215, 0)
Converted["_distance1"].Size = UDim2.new(0.0442708321, 0, 0.0194444451, 0)
Converted["_distance1"].Name = "distance"
Converted["_distance1"].Parent = Converted["_ScreenGui"]

Converted["_chestesp"].Font = Enum.Font.Sarpanch
Converted["_chestesp"].Text = "ChestEsp"
Converted["_chestesp"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_chestesp"].TextSize = 25
Converted["_chestesp"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_chestesp"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_chestesp"].BackgroundTransparency = 1
Converted["_chestesp"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_chestesp"].BorderSizePixel = 0
Converted["_chestesp"].Position = UDim2.new(0.413541675, 0, 0.401851892, 0)
Converted["_chestesp"].Size = UDim2.new(0.0473958328, 0, 0.0194444451, 0)
Converted["_chestesp"].Name = "chestesp"
Converted["_chestesp"].Parent = Converted["_ScreenGui"]

Converted["_chestesp1"].Font = Enum.Font.Sarpanch
Converted["_chestesp1"].Text = "■"
Converted["_chestesp1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_chestesp1"].TextSize = 20
Converted["_chestesp1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_chestesp1"].BackgroundTransparency = 1
Converted["_chestesp1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_chestesp1"].BorderSizePixel = 0
Converted["_chestesp1"].Position = UDim2.new(0.4609375, 0, 0.406481475, 0)
Converted["_chestesp1"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_chestesp1"].Name = "chestesp"
Converted["_chestesp1"].Parent = Converted["_ScreenGui"]

Converted["_tpwalk"].Font = Enum.Font.Sarpanch
Converted["_tpwalk"].Text = "■"
Converted["_tpwalk"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_tpwalk"].TextSize = 20
Converted["_tpwalk"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_tpwalk"].BackgroundTransparency = 1
Converted["_tpwalk"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_tpwalk"].BorderSizePixel = 0
Converted["_tpwalk"].Position = UDim2.new(0.453125, 0, 0.439814806, 0)
Converted["_tpwalk"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_tpwalk"].Name = "tpwalk"
Converted["_tpwalk"].Parent = Converted["_ScreenGui"]

Converted["_tpwalk1"].Font = Enum.Font.Sarpanch
Converted["_tpwalk1"].Text = "TpWalk"
Converted["_tpwalk1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_tpwalk1"].TextSize = 25
Converted["_tpwalk1"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_tpwalk1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_tpwalk1"].BackgroundTransparency = 1
Converted["_tpwalk1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_tpwalk1"].BorderSizePixel = 0
Converted["_tpwalk1"].Position = UDim2.new(0.413541675, 0, 0.435185254, 0)
Converted["_tpwalk1"].Size = UDim2.new(0.0473958328, 0, 0.0194444451, 0)
Converted["_tpwalk1"].Name = "tpwalk"
Converted["_tpwalk1"].Parent = Converted["_ScreenGui"]

Converted["_skinchange"].Font = Enum.Font.Sarpanch
Converted["_skinchange"].Text = "SkinChange"
Converted["_skinchange"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_skinchange"].TextSize = 25
Converted["_skinchange"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_skinchange"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_skinchange"].BackgroundTransparency = 1
Converted["_skinchange"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_skinchange"].BorderSizePixel = 0
Converted["_skinchange"].Position = UDim2.new(0.413541675, 0, 0.469444513, 0)
Converted["_skinchange"].Size = UDim2.new(0.0583333336, 0, 0.0194444451, 0)
Converted["_skinchange"].Name = "skinchange"
Converted["_skinchange"].Parent = Converted["_ScreenGui"]

Converted["_skinchange1"].Font = Enum.Font.Sarpanch
Converted["_skinchange1"].Text = "■"
Converted["_skinchange1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_skinchange1"].TextSize = 20
Converted["_skinchange1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_skinchange1"].BackgroundTransparency = 1
Converted["_skinchange1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_skinchange1"].BorderSizePixel = 0
Converted["_skinchange1"].Position = UDim2.new(0.475520819, 0, 0.474074066, 0)
Converted["_skinchange1"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_skinchange1"].Name = "skinchange"
Converted["_skinchange1"].Parent = Converted["_ScreenGui"]

Converted["_line"].Font = Enum.Font.Sarpanch
Converted["_line"].Text = "Line"
Converted["_line"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_line"].TextSize = 25
Converted["_line"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_line"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_line"].BackgroundTransparency = 1
Converted["_line"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_line"].BorderSizePixel = 0
Converted["_line"].Position = UDim2.new(0.526041687, 0, 0.372222215, 0)
Converted["_line"].Size = UDim2.new(0.0218749996, 0, 0.0194444451, 0)
Converted["_line"].Name = "line"
Converted["_line"].Parent = Converted["_ScreenGui"]

Converted["_line1"].Font = Enum.Font.Sarpanch
Converted["_line1"].Text = "■"
Converted["_line1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_line1"].TextSize = 20
Converted["_line1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_line1"].BackgroundTransparency = 1
Converted["_line1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_line1"].BorderSizePixel = 0
Converted["_line1"].Position = UDim2.new(0.547916651, 0, 0.375, 0)
Converted["_line1"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_line1"].Name = "line"
Converted["_line1"].Parent = Converted["_ScreenGui"]

Converted["_infjump"].Font = Enum.Font.Sarpanch
Converted["_infjump"].Text = "InfJump"
Converted["_infjump"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_infjump"].TextSize = 25
Converted["_infjump"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_infjump"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_infjump"].BackgroundTransparency = 1
Converted["_infjump"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_infjump"].BorderSizePixel = 0
Converted["_infjump"].Position = UDim2.new(0.413541675, 0, 0.502777815, 0)
Converted["_infjump"].Size = UDim2.new(0.0432291664, 0, 0.0194444451, 0)
Converted["_infjump"].Name = "infjump"
Converted["_infjump"].Parent = Converted["_ScreenGui"]

Converted["_infjump1"].Font = Enum.Font.Sarpanch
Converted["_infjump1"].Text = "■"
Converted["_infjump1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_infjump1"].TextSize = 20
Converted["_infjump1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_infjump1"].BackgroundTransparency = 1
Converted["_infjump1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_infjump1"].BorderSizePixel = 0
Converted["_infjump1"].Position = UDim2.new(0.456770837, 0, 0.507407427, 0)
Converted["_infjump1"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_infjump1"].Name = "infjump"
Converted["_infjump1"].Parent = Converted["_ScreenGui"]

Converted["_hitbox"].Font = Enum.Font.Sarpanch
Converted["_hitbox"].Text = "HitBox"
Converted["_hitbox"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_hitbox"].TextSize = 25
Converted["_hitbox"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_hitbox"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_hitbox"].BackgroundTransparency = 1
Converted["_hitbox"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_hitbox"].BorderSizePixel = 0
Converted["_hitbox"].Position = UDim2.new(0.413541675, 0, 0.537037015, 0)
Converted["_hitbox"].Size = UDim2.new(0.0333333313, 0, 0.0194444451, 0)
Converted["_hitbox"].Name = "hitbox"
Converted["_hitbox"].Parent = Converted["_ScreenGui"]

Converted["_hitbox1"].Font = Enum.Font.Sarpanch
Converted["_hitbox1"].Text = "■"
Converted["_hitbox1"].TextColor3 = Color3.fromRGB(255, 0, 0)
Converted["_hitbox1"].TextSize = 20
Converted["_hitbox1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_hitbox1"].BackgroundTransparency = 1
Converted["_hitbox1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_hitbox1"].BorderSizePixel = 0
Converted["_hitbox1"].Position = UDim2.new(0.449999988, 0, 0.541666687, 0)
Converted["_hitbox1"].Size = UDim2.new(0.0078125, 0, 0.0148147866, 0)
Converted["_hitbox1"].Name = "hitbox"
Converted["_hitbox1"].Parent = Converted["_ScreenGui"]

-- Fake Module Scripts:

local fake_module_scripts = {}


-- Fake Local Scripts:

local function AXNS_fake_script() -- Fake Script: StarterGui.ScreenGui.move
    local script = Instance.new("LocalScript")
    script.Name = "move"
    script.Parent = Converted["_ScreenGui"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	--------------------------------------------------------------------------------
	-- TweenService、UserInputService の取得
	--------------------------------------------------------------------------------
	local TweenService = game:GetService("TweenService")
	local UserInputService = game:GetService("UserInputService")
	
	--------------------------------------------------------------------------------
	-- Gui の参照
	--------------------------------------------------------------------------------
	local screenGui = script.Parent               -- このスクリプトが ScreenGui 直下にある想定
	local have = screenGui:WaitForChild("have")   -- ドラッグ用フレーム
	
	--------------------------------------------------------------------------------
	-- ドラッグ関連の変数
	--------------------------------------------------------------------------------
	local dragging = false
	local dragStart
	local initialPositions = {}
	
	--------------------------------------------------------------------------------
	-- 表示/非表示関連の変数
	--------------------------------------------------------------------------------
	local isVisible = true
	local fadeDuration = 0.25  -- 表示・非表示のアニメーション所要時間
	
	--------------------------------------------------------------------------------
	-- 「ドラッグ移動」をアニメーションさせる関数
	--------------------------------------------------------------------------------
	local function tweenMove(guiObject, newPos, duration)
		local tweenInfo = TweenInfo.new(
			duration,                       -- 時間
			Enum.EasingStyle.Linear,        -- アニメの種類
			Enum.EasingDirection.Out        -- 終わり際をゆっくり
		)
		local tween = TweenService:Create(guiObject, tweenInfo, {
			Position = newPos
		})
		tween:Play()
	end
	
	--------------------------------------------------------------------------------
	-- ドラッグ中に全ての GUI を動かす関数
	--------------------------------------------------------------------------------
	local function moveAllGUIs(input)
		local delta = input.Position - dragStart
		for guiObject, storedPos in pairs(initialPositions) do
			local newX = storedPos.X + delta.X
			local newY = storedPos.Y + delta.Y
			local newPos = UDim2.fromOffset(newX, newY)
	
			-- 滑らかに動かしたい場合は tweenMove
			tweenMove(guiObject, newPos, 0.1)
		end
	end
	
	--------------------------------------------------------------------------------
	-- GUI をフェードさせながら表示／非表示を切り替えるための処理
	--------------------------------------------------------------------------------
	
	-- 子要素を含めてフェードしたい場合は再帰的に呼ぶ
	local function tweenFade(guiObject, finalTransparency, duration)
		--------------------------------------------------------------------------------
		-- ■ TextLabel / TextButton：テキスト透明度のみを変更し、BackgroundTransparency はいじらない
		--------------------------------------------------------------------------------
		if guiObject:IsA("TextLabel") or guiObject:IsA("TextButton") then
			local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
			local goals = {
				TextTransparency = finalTransparency,
			}
			local tween = TweenService:Create(guiObject, tweenInfo, goals)
			tween:Play()
	
			--------------------------------------------------------------------------------
			-- ■ Frame / ScrollingFrame：背景だけフェードする（必要なら）
			--------------------------------------------------------------------------------
		elseif guiObject:IsA("Frame") or guiObject:IsA("ScrollingFrame") then
			local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
			local goals = {
				BackgroundTransparency = finalTransparency,
			}
			local tween = TweenService:Create(guiObject, tweenInfo, goals)
			tween:Play()
	
			--------------------------------------------------------------------------------
			-- ■ ImageLabel / ImageButton：画像と背景をフェードする（必要なら）
			--------------------------------------------------------------------------------
		elseif guiObject:IsA("ImageLabel") or guiObject:IsA("ImageButton") then
			local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
			local goals = {
				ImageTransparency = finalTransparency,
				BackgroundTransparency = finalTransparency,
			}
			local tween = TweenService:Create(guiObject, tweenInfo, goals)
			tween:Play()
		end
	
		--------------------------------------------------------------------------------
		-- 子要素を再帰的に処理する
		--------------------------------------------------------------------------------
		for _, child in ipairs(guiObject:GetChildren()) do
			if child:IsA("GuiObject") then
				tweenFade(child, finalTransparency, duration)
			end
		end
	end
	
	-- GUI 全体を「表示 → 非表示（フェードアウト）」または「非表示 → 表示（フェードイン）」へ切り替える関数
	local function toggleVisibility()
		isVisible = not isVisible  -- true <-> false の切り替え
	
		if isVisible then
			-- まず Visible = true にしてからフェードイン
			for _, child in ipairs(screenGui:GetChildren()) do
				if child:IsA("GuiObject") then
					child.Visible = true
					tweenFade(child, 0, fadeDuration) -- 0 = 不透明にする
				end
			end
		else
			-- フェードアウト完了後に Visible = false
			for _, child in ipairs(screenGui:GetChildren()) do
				if child:IsA("GuiObject") then
					tweenFade(child, 1, fadeDuration) -- 1 = 完全透明
	
					-- Tween 完了後に Visible = false
					local tweenInfo = TweenInfo.new(fadeDuration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
					local tween = TweenService:Create(child, tweenInfo, {})
					tween:Play()
					tween.Completed:Connect(function()
						child.Visible = false
					end)
				end
			end
		end
	end
	
	--------------------------------------------------------------------------------
	-- have フレームをクリックしたときの処理（ドラッグ開始）
	--------------------------------------------------------------------------------
	have.InputBegan:Connect(function(input)
		-- 左クリック（またはタッチ）の開始を検知したら
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
	
			-- ScreenGui 配下のすべての GUIObject の座標を保存
			for _, child in ipairs(screenGui:GetChildren()) do
				if child:IsA("GuiObject") then
					initialPositions[child] = child.AbsolutePosition
				end
			end
	
			-- マウスを離したかどうかチェック
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	--------------------------------------------------------------------------------
	-- マウス移動中の処理 (ドラッグ中なら全 GUI を移動)
	--------------------------------------------------------------------------------
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			moveAllGUIs(input)
		end
	end)
	
	--------------------------------------------------------------------------------
	-- 右シフト（RightShift）で全てを表示/非表示にする処理
	--------------------------------------------------------------------------------
	UserInputService.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Keyboard 
			and input.KeyCode == Enum.KeyCode.RightShift 
		then
			toggleVisibility()
		end
	end)
	
end
local function GVZY_fake_script() -- Fake Script: StarterGui.ScreenGui.have.UIStroke.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_UIStroke"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- UIStrokeを持つオブジェクトを参照します
	local stroke = script.Parent  -- このスクリプトがUIStrokeに直接親子関係にある場合
	
	-- 色相を時間とともに変化させる無限ループ
	while true do
		-- 0から1までの色相でループし、RGB色を設定
		for hue = 0, 1, 0.01 do
			stroke.Color = Color3.fromHSV(hue, 1, 1)  -- 飽和度と明度は最大値に設定
			wait(0.05)  -- 色の変化速度を調整
		end
	end
	
end
local function YOZS_fake_script() -- Fake Script: StarterGui.ScreenGui.title.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_title"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function OWCUEP_fake_script() -- Fake Script: StarterGui.ScreenGui.boxesp.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_boxesp"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function RYJX_fake_script() -- Fake Script: StarterGui.ScreenGui.boxesp.boxesponoff
    local script = Instance.new("LocalScript")
    script.Name = "boxesponoff"
    script.Parent = Converted["_boxesp1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	--[[ 
	    ボタンで切り替えるESP Box描画スクリプト（レインボーカラー対応）
	    WARNING: このスクリプトは未検証です。自己責任で使用してください。
	]]
	
	-- 必要なサービスの取得
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Camera = workspace.CurrentCamera
	
	local LocalPlayer = Players.LocalPlayer
	
	-- TextButtonを取得（このスクリプトはボタンの子として配置）
	local button = script.Parent
	
	-- ボタンの色設定
	local originalColor = button.TextColor3
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色と機能の状態フラグ
	local isGreen = false
	local featureEnabled = false
	
	-- ESPの定義
	local ESP = {}
	ESP.__index = ESP
	
	function ESP.new()
		local self = setmetatable({}, ESP)
		self.espCache = {}
		return self
	end
	
	function ESP:createDrawing(type, properties)
		local drawing = Drawing.new(type)
		for prop, val in pairs(properties) do
			drawing[prop] = val
		end
		return drawing
	end
	
	function ESP:createBoxComponent()
		return {
			Box = self:createDrawing("Square", {
				Thickness = 1,
				Transparency = 1,
				Color = Color3.fromRGB(255, 255, 255),  -- 初期色は白だが、更新でレインボーに変更
				Filled = false,
				Visible = false
			})
		}
	end
	
	function ESP:updateBox(components, character)
		local hrp = character:FindFirstChild("HumanoidRootPart")
		local humanoid = character:FindFirstChild("Humanoid")
	
		if hrp and humanoid then
			local hrpPosition, onScreen = Camera:WorldToViewportPoint(hrp.Position)
			if onScreen then
				local screenWidth, screenHeight = Camera.ViewportSize.X, Camera.ViewportSize.Y
				local factor = 1 / (hrpPosition.Z * math.tan(math.rad(Camera.FieldOfView * 0.5)) * 2) * 100
				local width = math.floor(screenWidth / 27 * factor)
				local height = math.floor(screenHeight / 25 * factor)
	
				-- レインボーカラーの計算と適用
				local hue = (tick() * 0.2) % 1  -- 色相を時間に応じて変化
				components.Box.Color = Color3.fromHSV(hue, 1, 1)
	
				components.Box.Size = Vector2.new(width, height)
				components.Box.Position = Vector2.new(hrpPosition.X - width / 2, hrpPosition.Y - height / 2)
				components.Box.Visible = true
			else
				components.Box.Visible = false
			end
		else
			components.Box.Visible = false
		end
	end
	
	function ESP:hideBox(components)
		components.Box.Visible = false
	end
	
	function ESP:removeEsp(player)
		local components = self.espCache[player]
		if components then
			components.Box:Remove()
			self.espCache[player] = nil
		end
	end
	
	local espInstance = ESP.new()
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if isGreen then
			button.TextColor3 = originalColor
			featureEnabled = false
			print("ESP Box Disabled")
		else
			button.TextColor3 = greenColor
			featureEnabled = true
			print("ESP Box Enabled")
		end
		isGreen = not isGreen
	end)
	
	-- プレイヤー更新処理
	RunService.RenderStepped:Connect(function()
		if featureEnabled then
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= LocalPlayer then
					local character = player.Character
					if character then
						if not espInstance.espCache[player] then
							espInstance.espCache[player] = espInstance:createBoxComponent()
						end
						espInstance:updateBox(espInstance.espCache[player], character)
					else
						if espInstance.espCache[player] then
							espInstance:hideBox(espInstance.espCache[player])
						end
					end
				end
			end
		else
			-- 機能無効時は全Boxを非表示に
			for _, components in pairs(espInstance.espCache) do
				if components then
					espInstance:hideBox(components)
				end
			end
		end
	end)
	
	Players.PlayerRemoving:Connect(function(player)
		espInstance:removeEsp(player)
	end)
	
end
local function ERHRWRP_fake_script() -- Fake Script: StarterGui.ScreenGui.distance.distanceonoff
    local script = Instance.new("LocalScript")
    script.Name = "distanceonoff"
    script.Parent = Converted["_distance"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- 必要なサービスの取得
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Camera = workspace.CurrentCamera
	
	local LocalPlayer = Players.LocalPlayer
	
	-- TextButtonを取得（このスクリプトはボタンの子として配置）
	local button = script.Parent
	
	-- 元のテキストの色を保存
	local originalColor = button.TextColor3
	-- 緑色の定義
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態を管理するフラグ
	local isGreen = false
	-- 機能のオンオフを管理するフラグ
	local featureEnabled = false
	
	-- 各プレイヤーキャラクターに対応する距離テキストを管理するテーブル
	local distanceTexts = {}
	
	-- Drawing.Textを作成する関数
	local function createDistanceText()
		local text = Drawing.new("Text")
		text.Size = 18
		text.Outline = true
		text.OutlineColor = Color3.new(0, 0, 0) -- 黒
		text.Center = true
		text.Visible = false
		return text
	end
	
	-- 指定されたキャラクターモデルに対して距離テキストを設定する関数
	local function setupCharacterDistance(character)
		-- Headの存在を待機（最大5秒）
		local head = character:WaitForChild("Head", 5)
		if not head then
			return
		end
	
		if not distanceTexts[character] then
			local distanceText = createDistanceText()
			distanceTexts[character] = {
				TextObject = distanceText,
				Head = head
			}
		else
			distanceTexts[character].Head = head
		end
	end
	
	-- 既存のプレイヤーキャラクターをセットアップ
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			if player.Character then
				setupCharacterDistance(player.Character)
			end
			-- キャラクターが存在しない場合CharacterAddedイベントで待機
			player.CharacterAdded:Connect(function(character)
				setupCharacterDistance(character)
			end)
		end
	end
	
	-- 新しいプレイヤーが参加したらCharacterAddedを監視
	Players.PlayerAdded:Connect(function(player)
		if player ~= LocalPlayer then
			player.CharacterAdded:Connect(function(character)
				setupCharacterDistance(character)
			end)
		end
	end)
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if isGreen then
			button.TextColor3 = originalColor
			featureEnabled = false
			print("Distance Display Disabled")
		else
			button.TextColor3 = greenColor
			featureEnabled = true
			print("Distance Display Enabled")
		end
		isGreen = not isGreen
	end)
	
	-- 毎フレーム距離テキストを更新
	RunService.RenderStepped:Connect(function()
		if featureEnabled then
			for character, data in pairs(distanceTexts) do
				local head = data.Head
				local textObj = data.TextObject
	
				if head and head:IsDescendantOf(workspace) then
					local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)
					if onScreen then
						local distance = (Camera.CFrame.Position - head.Position).Magnitude
						textObj.Text = string.format("[%dM]", math.floor(distance))
	
						-- レインボーカラーの計算と適用
						local hue = (tick() * 0.2) % 1  -- 時間に応じて色相を変化
						textObj.Color = Color3.fromHSV(hue, 1, 1)
	
						local offsetY = -20
						textObj.Position = Vector2.new(headPos.X, headPos.Y + offsetY)
						textObj.Visible = true
					else
						textObj.Visible = false
					end
				else
					textObj.Visible = false
				end
			end
		else
			for _, data in pairs(distanceTexts) do
				if data.TextObject then
					data.TextObject.Visible = false
				end
			end
		end
	end)
	
	-- キャラクターがWorkspaceから削除されたときの処理
	workspace.ChildRemoved:Connect(function(child)
		if distanceTexts[child] then
			local data = distanceTexts[child]
			if data.TextObject then
				data.TextObject:Remove()
			end
			distanceTexts[child] = nil
		end
	end)
	
end
local function QYLZNZC_fake_script() -- Fake Script: StarterGui.ScreenGui.distance.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_distance1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function VHJPWE_fake_script() -- Fake Script: StarterGui.ScreenGui.chestesp.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_chestesp"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function OEFIYJZ_fake_script() -- Fake Script: StarterGui.ScreenGui.chestesp.chestesponoff
    local script = Instance.new("LocalScript")
    script.Name = "chestesponoff"
    script.Parent = Converted["_chestesp1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	local player = game.Players.LocalPlayer
	local camera = workspace.CurrentCamera
	
	-- TextButtonを取得
	local button = script.Parent
	
	-- 元のテキストの色を保存
	local originalColor = button.TextColor3
	-- 緑色の定義
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態を管理するフラグ
	local isGreen = false
	
	-- ESP用のBillboardGuiを管理するテーブル
	local esps = {}
	
	-- モデルにESP表示を作成する関数
	local function createESPForModel(model)
		if not model.PrimaryPart then
			warn(model.Name .. " にPrimaryPartが設定されていません。")
			return
		end
	
		local billboardGui = Instance.new("BillboardGui")
		billboardGui.Name = "ESP_Billboard"
		billboardGui.Adornee = model.PrimaryPart
		billboardGui.Size = UDim2.new(0, 100, 0, 50)
		billboardGui.AlwaysOnTop = true
	
		local textLabel = Instance.new("TextLabel")
		textLabel.Size = UDim2.new(1, 0, 1, 0)
		textLabel.BackgroundTransparency = 1
		textLabel.Text = model.Name
		textLabel.TextColor3 = Color3.new(1, 0, 0)
		textLabel.TextStrokeTransparency = 0
		textLabel.Parent = billboardGui
	
		billboardGui.Parent = model
	
		table.insert(esps, billboardGui)
	end
	
	-- ESPを全て削除する関数
	local function removeAllESP()
		for _, billboard in ipairs(esps) do
			if billboard and billboard.Parent then
				billboard:Destroy()
			end
		end
		esps = {}  -- テーブルをリセット
	end
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if isGreen then
			-- 現在緑色の場合：色を元に戻し、ESPを削除
			button.TextColor3 = originalColor
			removeAllESP()
		else
			-- 緑色でない場合：色を緑にし、ESPを作成
			button.TextColor3 = greenColor
	
			local chestsFolder = workspace:FindFirstChild("Chests")
			if chestsFolder then
				for _, item in ipairs(chestsFolder:GetChildren()) do
					if item:IsA("Model") then
						createESPForModel(item)
					end
				end
			else
				warn("Chestsフォルダが見つかりません")
			end
		end
	
		-- 状態を反転
		isGreen = not isGreen
	end)
	
end
local function QNNFEI_fake_script() -- Fake Script: StarterGui.ScreenGui.tpwalk.tpwalkonoff
    local script = Instance.new("LocalScript")
    script.Name = "tpwalkonoff"
    script.Parent = Converted["_tpwalk"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- 必要なサービスの取得
	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local RunService = game:GetService("RunService")
	
	local LocalPlayer = Players.LocalPlayer
	
	-- TextButtonの取得（このスクリプトはボタンの子として配置）
	local button = script:FindFirstChildWhichIsA("TextButton") or script.Parent
	
	-- ボタンの色設定
	local originalColor = button.TextColor3
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態と機能のオンオフを管理するフラグ
	local isGreen = false
	local featureEnabled = false
	
	-- キャラクターと移動に関する設定
	local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
	local moveIncrement = 0.7
	
	-- 現在の移動方向を保持するテーブル
	local moveDirection = {
		forward = false,
		backward = false,
		left = false,
		right = false
	}
	
	-- キー入力が始まったときの処理
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		local key = input.KeyCode
		if key == Enum.KeyCode.W or key == Enum.KeyCode.Up then
			moveDirection.forward = true
		elseif key == Enum.KeyCode.S or key == Enum.KeyCode.Down then
			moveDirection.backward = true
		elseif key == Enum.KeyCode.A or key == Enum.KeyCode.Left then
			moveDirection.left = true
		elseif key == Enum.KeyCode.D or key == Enum.KeyCode.Right then
			moveDirection.right = true
		end
	end)
	
	-- キー入力が終了したときの処理
	UserInputService.InputEnded:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		local key = input.KeyCode
		if key == Enum.KeyCode.W or key == Enum.KeyCode.Up then
			moveDirection.forward = false
		elseif key == Enum.KeyCode.S or key == Enum.KeyCode.Down then
			moveDirection.backward = false
		elseif key == Enum.KeyCode.A or key == Enum.KeyCode.Left then
			moveDirection.left = false
		elseif key == Enum.KeyCode.D or key == Enum.KeyCode.Right then
			moveDirection.right = false
		end
	end)
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if isGreen then
			button.TextColor3 = originalColor
			featureEnabled = false
			print("TPWalk Disabled")
		else
			button.TextColor3 = greenColor
			featureEnabled = true
			print("TPWalk Enabled")
		end
		isGreen = not isGreen
	end)
	
	-- 毎フレームの処理
	RunService.RenderStepped:Connect(function()
		if featureEnabled then
			-- キャラクターやHumanoidRootPartが無効な場合は再取得
			if not character or not character.Parent then
				character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
				humanoidRootPart = character:WaitForChild("HumanoidRootPart")
			end
	
			local moveVector = Vector3.new(0, 0, 0)
			local cf = humanoidRootPart.CFrame
			local forwardVector = cf.LookVector
			local rightVector = cf.RightVector
	
			if moveDirection.forward then
				moveVector = moveVector + forwardVector
			end
			if moveDirection.backward then
				moveVector = moveVector - forwardVector
			end
			if moveDirection.left then
				moveVector = moveVector - rightVector
			end
			if moveDirection.right then
				moveVector = moveVector + rightVector
			end
	
			if moveVector.Magnitude > 0 then
				moveVector = moveVector.Unit * moveIncrement
				local currentCFrame = humanoidRootPart.CFrame
				local newCFrame = currentCFrame + moveVector
				humanoidRootPart.CFrame = newCFrame
			end
		end
	end)
	
end
local function KQNDAD_fake_script() -- Fake Script: StarterGui.ScreenGui.tpwalk.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_tpwalk1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function QJFJ_fake_script() -- Fake Script: StarterGui.ScreenGui.skinchange.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_skinchange"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function YHVWJNQ_fake_script() -- Fake Script: StarterGui.ScreenGui.skinchange.skinchangeonoff
    local script = Instance.new("LocalScript")
    script.Name = "skinchangeonoff"
    script.Parent = Converted["_skinchange1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextButtonを取得
	local button = script.Parent
	
	-- 元のテキストの色を保存
	local originalColor = button.TextColor3
	-- 緑色の定義
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態を管理するフラグ
	local isGreen = false
	
	-- 変更したいテクスチャID
	local newTextureId = "http://www.roblox.com/asset/?id=104373329184787"
	
	-- 透明度の設定（テンプレートとして使用する値）
	local defaultTransparency = 0.6
	local humanoidRootTransparency = 1
	
	-- キャラクター対象のパーツ一覧（Headを除外）
	local partNames = {
		"LeftFoot", "LeftHand", "LeftLowerArm", "LeftLowerLeg",
		"LeftUpperArm", "LeftUpperLeg", "LowerTorso", "RightFoot",
		"RightHand", "RightLowerArm", "RightLowerLeg", "RightUpperArm",
		"RightUpperLeg", "UpperTorso", "HumanoidRootPart"
	}
	
	local player = game.Players.LocalPlayer
	if not player then
		warn("プレイヤーが見つかりません。")
		return
	end
	
	-- 各パーツの元のTextureIDと透明度を保存するテーブル（キャラクター用）
	local originalData = {}  -- originalData[partName] = { texture = ..., transparency = ... }
	
	-- StarterCharacter内の各パーツの元のデータを保存するテーブル
	local starterOriginalData = {}  
	-- starterOriginalData[obj] = { texture = ..., transparency = ... }
	
	-- プレイヤーのキャラクター取得ヘルパー
	local function getCharacter()
		return player.Character or player.CharacterAdded:Wait()
	end
	
	-- 特定のオブジェクトが「Brown Hair」の子孫に含まれるかチェックする関数
	local function isUnderBrownHair(obj)
		local current = obj
		while current do
			if current.Name == "Brown Hair" then
				return true
			end
			current = current.Parent
		end
		return false
	end
	
	-- Workspace内のStarterCharacter内のパーツにテクスチャと透明度を適用する関数
	local function applyTextureToStarterCharacter()
		local targetFolder = workspace:FindFirstChild("Lobby")
			and workspace.Lobby:FindFirstChild("MainPad")
			and workspace.Lobby.MainPad:FindFirstChild("Spawn")
			and workspace.Lobby.MainPad.Spawn:FindFirstChild("StarterCharacter")
		if not targetFolder then
			warn("StarterCharacter フォルダが見つかりません。")
			return
		end
	
		for _, obj in ipairs(targetFolder:GetDescendants()) do
			-- Headは除外し、「Brown Hair」以下のパーツも除外
			if obj:IsA("BasePart") and obj.Name ~= "Head" and not isUnderBrownHair(obj) then
				-- 元のテクスチャと透明度を保存
				if not starterOriginalData[obj] then
					starterOriginalData[obj] = {
						texture = nil,
						transparency = obj.Transparency
					}
					if obj:IsA("MeshPart") then
						starterOriginalData[obj].texture = obj.TextureID
					elseif obj:FindFirstChildWhichIsA("Texture") then
						local tex = obj:FindFirstChildWhichIsA("Texture")
						if tex then
							starterOriginalData[obj].texture = tex.Texture
						end
					end
				end
	
				-- 透明度を設定（HumanoidRootPartは1、それ以外は0.6）
				if obj.Name == "HumanoidRootPart" then
					obj.Transparency = humanoidRootTransparency
				else
					obj.Transparency = defaultTransparency
				end
	
				-- テクスチャ変更処理
				if obj:IsA("MeshPart") then
					obj.TextureID = newTextureId
				elseif obj:FindFirstChildWhichIsA("Texture") then
					for _, child in ipairs(obj:GetChildren()) do
						if child:IsA("Texture") then
							child.Texture = newTextureId
						end
					end
				end
			end
		end
	end
	
	-- StarterCharacter内のパーツのテクスチャと透明度を元に戻す関数
	local function revertTextureOfStarterCharacter()
		for obj, data in pairs(starterOriginalData) do
			if obj and obj.Parent then
				-- 元の透明度を復元
				obj.Transparency = data.transparency
	
				-- 元のテクスチャを復元
				if obj:IsA("MeshPart") and data.texture then
					obj.TextureID = data.texture
				elseif obj:FindFirstChildWhichIsA("Texture") and data.texture then
					for _, child in ipairs(obj:GetChildren()) do
						if child:IsA("Texture") then
							child.Texture = data.texture
						end
					end
				end
			end
		end
		-- 保存データをクリア
		starterOriginalData = {}
	end
	
	-- 指定されたテクスチャに変更し、透明度を設定する関数
	local function applyNewTexture(character)
		originalData = {}
	
		for _, partName in ipairs(partNames) do
			local part = character:FindFirstChild(partName)
			if part and part:IsA("BasePart") then
				if not originalData[partName] then
					originalData[partName] = {
						transparency = part.Transparency,
						texture = nil
					}
					if part:IsA("MeshPart") then
						originalData[partName].texture = part.TextureID
					elseif part:FindFirstChildWhichIsA("Texture") then
						local tex = part:FindFirstChildWhichIsA("Texture")
						if tex then
							originalData[partName].texture = tex.Texture
						end
					end
				end
	
				if partName == "HumanoidRootPart" then
					part.Transparency = humanoidRootTransparency
				else
					part.Transparency = defaultTransparency
				end
	
				if part:IsA("MeshPart") then
					part.TextureID = newTextureId
				elseif part:FindFirstChildWhichIsA("Texture") then
					for _, child in ipairs(part:GetChildren()) do
						if child:IsA("Texture") then
							child.Texture = newTextureId
						end
					end
				end
			end
		end
	
		applyTextureToStarterCharacter()
	end
	
	-- 元のテクスチャと透明度に戻す関数
	local function revertOriginalTexture(character)
		for _, partName in ipairs(partNames) do
			local part = character:FindFirstChild(partName)
			local data = originalData[partName]
			if part and data then
				part.Transparency = data.transparency
	
				if part:IsA("MeshPart") and data.texture then
					part.TextureID = data.texture
				elseif part:FindFirstChildWhichIsA("Texture") and data.texture then
					for _, child in ipairs(part:GetChildren()) do
						if child:IsA("Texture") then
							child.Texture = data.texture
						end
					end
				end
			end
		end
	
		revertTextureOfStarterCharacter()
	end
	
	local character = getCharacter()
	
	player.CharacterAdded:Connect(function(newCharacter)
		character = newCharacter
		newCharacter:WaitForChild("Humanoid")
	
		if isGreen then
			applyNewTexture(newCharacter)
		else
			originalData = {}
			starterOriginalData = {}
		end
	end)
	
	button.MouseButton1Click:Connect(function()
		if isGreen then
			button.TextColor3 = originalColor
			revertOriginalTexture(character)
		else
			button.TextColor3 = greenColor
			applyNewTexture(character)
		end
		isGreen = not isGreen
	end)
	
end
local function SFVVXB_fake_script() -- Fake Script: StarterGui.ScreenGui.line.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_line"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function LYXCNL_fake_script() -- Fake Script: StarterGui.ScreenGui.line.lineonoff
    local script = Instance.new("LocalScript")
    script.Name = "lineonoff"
    script.Parent = Converted["_line1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- 必要なサービスの取得
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Camera = workspace.CurrentCamera
	
	-- TextButtonの取得（このスクリプトはボタンの子として配置）
	local button = script:FindFirstChildWhichIsA("TextButton") or script.Parent
	
	-- ボタンの色設定
	local originalColor = button.TextColor3
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態と機能のオンオフを管理するフラグ
	local isGreen = false
	local featureEnabled = false
	
	local LocalPlayer = Players.LocalPlayer
	
	-- 他プレイヤーごとのラインを管理するテーブル
	local playerLines = {}
	
	-- 指定されたプレイヤー用のラインを作成する関数
	local function createLineForPlayer(player)
		if player == LocalPlayer then return end
		local line = Drawing.new("Line")
		line.Thickness = 2
		line.Transparency = 1
		line.Visible = false
		playerLines[player] = line
	end
	
	-- 存在する全てのプレイヤーにラインを作成
	for _, player in ipairs(Players:GetPlayers()) do
		createLineForPlayer(player)
	end
	
	-- 新しいプレイヤーが参加したらラインを作成
	Players.PlayerAdded:Connect(function(player)
		createLineForPlayer(player)
	end)
	
	-- プレイヤーが退出したら対応するラインを削除
	Players.PlayerRemoving:Connect(function(player)
		local line = playerLines[player]
		if line then
			line:Remove()
			playerLines[player] = nil
		end
	end)
	
	-- ボタンクリック時の処理で機能を切り替え
	button.MouseButton1Click:Connect(function()
		if isGreen then
			button.TextColor3 = originalColor
			featureEnabled = false
			print("Line drawing Disabled")
		else
			button.TextColor3 = greenColor
			featureEnabled = true
			print("Line drawing Enabled")
		end
		isGreen = not isGreen
	end)
	
	-- 毎フレームラインを更新する処理
	RunService.RenderStepped:Connect(function()
		if featureEnabled then
			local screenSize = Camera.ViewportSize
			local bottomCenter = Vector2.new(screenSize.X / 2, screenSize.Y)  -- 画面下部中央の座標
	
			for player, line in pairs(playerLines) do
				local character = player.Character
				if character then
					local head = character:FindFirstChild("Head")
					if head then
						local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)
						if onScreen then
							-- レインボーカラーの計算
							local hue = (tick() * 0.2) % 1
							line.Color = Color3.fromHSV(hue, 1, 1)
	
							line.From = bottomCenter
							line.To = Vector2.new(headPos.X, headPos.Y)
							line.Visible = true
						else
							line.Visible = false
						end
					else
						line.Visible = false
					end
				else
					line.Visible = false
				end
			end
		else
			-- 機能無効時は全てのラインを非表示
			for _, line in pairs(playerLines) do
				if line then
					line.Visible = false
				end
			end
		end
	end)
	
end
local function QRSN_fake_script() -- Fake Script: StarterGui.ScreenGui.infjump.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_infjump"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function EHUSZR_fake_script() -- Fake Script: StarterGui.ScreenGui.infjump.infjumponoff
    local script = Instance.new("LocalScript")
    script.Name = "infjumponoff"
    script.Parent = Converted["_infjump1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	
	local button = script.Parent
	
	-- ボタンの色設定
	local originalColor = button.TextColor3
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態と機能のフラグ
	local isGreen = false
	local infJumpEnabled = false
	
	local LocalPlayer = Players.LocalPlayer
	
	-- ボタンクリック時の処理でInfJump機能を切り替え
	button.MouseButton1Click:Connect(function()
		if isGreen then
			button.TextColor3 = originalColor
			infJumpEnabled = false
			print("InfJump Disabled")
		else
			button.TextColor3 = greenColor
			infJumpEnabled = true
			print("InfJump Enabled")
		end
		isGreen = not isGreen
	end)
	
	-- スペースキーの入力を監視し、InfJumpが有効な場合にジャンプを発動
	UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
		if gameProcessedEvent then return end
		if input.KeyCode == Enum.KeyCode.Space and infJumpEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end
		end
	end)
	
end
local function FTQPJ_fake_script() -- Fake Script: StarterGui.ScreenGui.hitbox.rainbow
    local script = Instance.new("LocalScript")
    script.Name = "rainbow"
    script.Parent = Converted["_hitbox"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextLabelへの参照を取得
	local textLabel = script.Parent
	
	while true do
		-- 現在の時間を取得し、周期的に変化する値（0～1の範囲）を計算
		local hue = (tick() % 5) / 5  -- 約5秒で1周する虹色を生成
		-- HSV色空間を使用して虹色を作成
		textLabel.TextColor3 = Color3.fromHSV(hue, 1, 1)
	
		-- 色の更新頻度を調整（例: 0.1秒毎に更新）
		wait(0.1)
	end
	
end
local function MKEZAHR_fake_script() -- Fake Script: StarterGui.ScreenGui.hitbox.hitboxonoff
    local script = Instance.new("LocalScript")
    script.Name = "hitboxonoff"
    script.Parent = Converted["_hitbox1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- TextButtonを取得
	local button = script.Parent
	
	-- 元のテキストの色を保存
	local originalColor = button.TextColor3
	-- 緑色の定義
	local greenColor = Color3.fromRGB(0, 255, 0)
	
	-- 色の切り替え状態を管理するフラグ
	local isGreen = false
	
	-- Servicesの取得
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	
	-- プレイヤーごとの新しいHeadパートを管理するテーブル
	local playerNewHeads = {}
	
	-- 指定されたキャラクターに新しいHeadを追加する関数
	local function tryAddHeadToCharacter(character)
		local player = Players:GetPlayerFromCharacter(character)
		if not player or player == Players.LocalPlayer then
			return
		end
	
		-- 既存のHeadを探す
		local existingHead = character:FindFirstChild("Head")
		if not existingHead then return end
	
		-- 既に新しいHeadが追加されている場合はスキップ
		if character:FindFirstChild("NewHead") then return end
	
		-- 新しいHeadパートを作成し、キャラクターに追加
		local newHead = Instance.new("Part")
		newHead.Name = "NewHead"                
		newHead.Size = Vector3.new(25, 25, 25)
		newHead.Transparency = 0.4
		newHead.Anchored = true
		newHead.CanCollide = false
		newHead.Parent = character
		newHead.CFrame = existingHead.CFrame
	
		-- 既存のHeadに追随させる更新関数を設定
		local connection
		connection = RunService.Heartbeat:Connect(function()
			if existingHead and existingHead.Parent then
				newHead.CFrame = existingHead.CFrame
			else
				connection:Disconnect()
			end
		end)
	
		-- 作成したHeadをテーブルに保存
		playerNewHeads[player.UserId] = newHead
	end
	
	-- 緑色になったときに全プレイヤーに新しいHeadを追加する処理
	local function addHeads()
		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= Players.LocalPlayer then
				local character = player.Character
				if character then
					tryAddHeadToCharacter(character)
				end
			end
		end
	end
	
	-- 元の状態に戻すときに新しいHeadを削除する処理
	local function removeHeads()
		for userId, head in pairs(playerNewHeads) do
			if head and head.Parent then
				head:Destroy()
			end
			playerNewHeads[userId] = nil
		end
	end
	
	-- ボタンクリック時の処理
	button.MouseButton1Click:Connect(function()
		if isGreen then
			-- 緑色状態から元の色に戻る場合、新しいHeadを削除
			button.TextColor3 = originalColor
			removeHeads()
		else
			-- 緑色に変える場合、新しいHeadを追加
			button.TextColor3 = greenColor
			addHeads()
		end
		-- 状態を反転
		isGreen = not isGreen
	end)
	
	-- プレイヤーが後から参加またはキャラクターが追加された場合にも対応
	Players.PlayerAdded:Connect(function(player)
		player.CharacterAdded:Connect(function(character)
			-- 現在緑色の場合のみHeadを追加
			if isGreen then
				tryAddHeadToCharacter(character)
			end
		end)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		player.CharacterAdded:Connect(function(character)
			if isGreen then
				tryAddHeadToCharacter(character)
			end
		end)
	end
	
end

coroutine.wrap(AXNS_fake_script)()
coroutine.wrap(GVZY_fake_script)()
coroutine.wrap(YOZS_fake_script)()
coroutine.wrap(OWCUEP_fake_script)()
coroutine.wrap(RYJX_fake_script)()
coroutine.wrap(ERHRWRP_fake_script)()
coroutine.wrap(QYLZNZC_fake_script)()
coroutine.wrap(VHJPWE_fake_script)()
coroutine.wrap(OEFIYJZ_fake_script)()
coroutine.wrap(QNNFEI_fake_script)()
coroutine.wrap(KQNDAD_fake_script)()
coroutine.wrap(QJFJ_fake_script)()
coroutine.wrap(YHVWJNQ_fake_script)()
coroutine.wrap(SFVVXB_fake_script)()
coroutine.wrap(LYXCNL_fake_script)()
coroutine.wrap(QRSN_fake_script)()
coroutine.wrap(EHUSZR_fake_script)()
coroutine.wrap(FTQPJ_fake_script)()
coroutine.wrap(MKEZAHR_fake_script)()
